#ifndef __LLVM_STATEPOINT_UTILS_API__
#define __LLVM_STATEPOINT_UTILS_API__

/**** Types ****/

typedef struct {
    // kind < 0 means this is a base pointer
    // kind >= 0 means this is a pointer derived from base pointer in slot number "kind"
    int32_t kind;    
    int32_t offset;  // offsets are relative to the frame's base
} pointer_slot_t;

typedef struct {
    // NOTE flags & calling convention didn't seem useful to include in the map.
    uint64_t retAddr;
    uint64_t frameSize;     // in bytes
    
    // all base pointers come before derived pointers in the slot array. you can use this
    // fact to quickly update the derived pointers by referring back to the base pointers
    // while scanning the slots.
    uint64_t numSlots;
    pointer_slot_t slots[];  
} frame_info_t;


typedef struct {
    uint16_t numEntries;
    frame_info_t* entries;
} table_bucket_t;

typedef struct {
    uint64_t size; 
    table_bucket_t* buckets;
} statepoint_table_t;



/**** Public Functions ****/

/**
 * An amortized O(1) return address lookup function for garbage collectors.
 *
 * table - table generated by generate_table
 * retAddr - the key (a return address) corresponding to the frame you need info about.
 *
 */
frame_info_t* lookup_return_address(statepoint_table_t *table, uint64_t retAddr);

/**
 * Given an LLVM generated Stack Map, will return a table suitable for
 * efficient return address -> pointer location lookups by a garbage collector.
 *
 */
statepoint_table_t* generate_table(void* map, float load_factor);


/**
 * Frees the memory allocated for the table.
 */
void destroy_table(statepoint_table_t* table);


#endif /* __LLVM_STATEPOINT_UTILS_API__ */
